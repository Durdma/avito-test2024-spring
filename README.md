# Тестовое задание для стажёра Backend
## Сервис баннеров
В Авито есть большое количество неоднородного контента, для которого необходимо иметь единую систему управления.  В частности, необходимо показывать разный контент пользователям в зависимости от их принадлежности к какой-либо группе. Данный контент мы будем предоставлять с помощью баннеров.
## Описание задачи
Необходимо реализовать сервис, который позволяет показывать пользователям баннеры, в зависимости от требуемой фичи и тега пользователя, а также управлять баннерами и связанными с ними тегами и фичами.
## Общие вводные
**Баннер** — это документ, описывающий какой-либо элемент пользовательского интерфейса. Технически баннер представляет собой  JSON-документ неопределенной структуры. 
**Тег** — это сущность для обозначения группы пользователей; представляет собой число (ID тега). 
**Фича** — это домен или функциональность; представляет собой число (ID фичи).  
1. Один баннер может быть связан только с одной фичей и несколькими тегами
2. При этом один тег, как и одна фича, могут принадлежать разным баннерам одновременно
3. Фича и тег однозначно определяют баннер

Так как баннеры являются для пользователя вспомогательным функционалом, допускается, если пользователь в течение короткого срока будет получать устаревшую информацию.  При этом существует часть пользователей (порядка 10%), которым обязательно получать самую актуальную информацию. Для таких пользователей нужно предусмотреть механизм получения информации напрямую из БД.
## Условия
1. Используйте этот [API](https://github.com/avito-tech/backend-trainee-assignment-2024/blob/main/api.yaml)
2. Тегов и фичей небольшое количество (до 1000), RPS — 1k, SLI времени ответа — 50 мс, SLI успешности ответа — 99.99%
3. Для авторизации доступов должны использоваться 2 вида токенов: пользовательский и админский.  Получение баннера может происходить с помощью пользовательского или админского токена, а все остальные действия могут выполняться только с помощью админского токена.  
4. Реализуйте интеграционный или E2E-тест на сценарий получения баннера.
5. Если при получении баннера передан флаг use_last_revision, необходимо отдавать самую актуальную информацию.  В ином случае допускается передача информации, которая была актуальна 5 минут назад.
6. Баннеры могут быть временно выключены. Если баннер выключен, то обычные пользователи не должны его получать, при этом админы должны иметь к нему доступ.

## Дополнительные задания:
Эти задания не являются обязательными, но выполнение всех или части из них даст вам преимущество перед другими кандидатами. 
1. Адаптировать систему для значительного увеличения количества тегов и фичей, при котором допускается увеличение времени исполнения по редко запрашиваемым тегам и фичам
2. Провести нагрузочное тестирование полученного решения и приложить результаты тестирования к решению
3. Иногда получается так, что необходимо вернуться к одной из трех предыдущих версий баннера в связи с найденной ошибкой в логике, тексте и т.д.  Измените API таким образом, чтобы можно было просмотреть существующие версии баннера и выбрать подходящую версию
4. Добавить метод удаления баннеров по фиче или тегу, время ответа которого не должно превышать 100 мс, независимо от количества баннеров.  В связи с небольшим временем ответа метода, рекомендуется ознакомиться с механизмом выполнения отложенных действий 
5. Реализовать интеграционное или E2E-тестирование для остальных сценариев
6. Описать конфигурацию линтера

## Требования по стеку
- **Язык сервиса:** предпочтительным будет Go, при этом вы можете выбрать любой, удобный вам. 
- **База данных:** предпочтительной будет PostgreSQL, при этом вы можете выбрать любую, удобную вам. 
- Для **деплоя зависимостей и самого сервиса** рекомендуется использовать Docker и Docker Compose.
## Ход решения
Если у вас возникнут вопросы по заданию, ответы на которые вы не найдете в описанных «Условиях», то вы вольны принимать решения самостоятельно.  
В таком случае приложите к проекту README-файл, в котором будет список вопросов и пояснения о том, как вы решили проблему и почему именно выбранным вами способом.
## Оформление решения
Необходимо предоставить публичный git-репозиторий на любом публичном хосте (GitHub / GitLab / etc), содержащий в master/main ветке: 
1. Код сервиса
2. Makefile c командами сборки проекта / Описанная в README.md инструкция по запуску
3. Описанные в README.md вопросы/проблемы, с которыми столкнулись,  и ваша логика их решений (если требуется)

## Решение
В ходе выполнения данной работы были выполнены следующие пункты:
1. API в соответствии с заданием (документация API предоставлена в виде ``avito spring 2024.postman_collection.json`` и в ``/docs/swagger.json; /docs/swagger.yaml``)
2. Были реализованы дополнительные эндпоинты для более удобного тестирования и управления API;
3. Была реализована авторизация доступа к API. Все endpoint защищены Bearer Token Auth за исключением endpoints группы users. Это было сделано с той целью, чтобы было проще начать взаимодействовать с системой. Токены не имеют срока годности.
   Это было сделано для того, чтобы было проще тестировать и использовать данное API в рамках задания.
   Для реализации полной системы авторизации можно было создать для пользователей поле Session, в котором хранился бы RefreshToken для обновления AccessToken, задать время истечения сроков годности токенов, эндпоинт для их обновления.
4. Был сделан e2e-тест получения баннера пользователя. В связи с нехваткой времени был реализован, не самым хорошим способом, тест на удачное получение баннера.
   **Примечание:** Тест работает при запущенной сущности приложения. То есть перед запуском теста необходимо запустить приложение.
5. Для реализации получения актуальной и не очень информации было решено использовать кэширование. Для этого была выбрана Redis.
   При выполнении первых запросов пользователи всегда идут в основную БД, и если запись есть, то она возвращается пользователям, а также записывается в redis на 5 минут.
   Если есть пользователь, который выполнил запрос с флагом ``use_last_revision``, то он идет в основную БД, получает запись и обновляет ее в redis.
   Если запись была скрыта от обычных пользователей, то она удаляется из redis сразу же до истечения 5 минутного срока хранения. Тоже самое происходит и при удалении связанного баннера.
6. Некоторые замечания по взаимодействию с API:
     - При первом запуске контейнера приложения ``banners_api_container`` выдает ошибку подключения к БД: ``failed to connect to `host=postgresdb user=postgress database=banners_db`: dial error (dial tcp 192.168.160.2:5432: connect: connection refused)``, для решения проблемы был поставлен таймер в 15сек для отложенного подключения к БД, однако, этоне решило проблему. Необходимо перезапустить контейнер ``banners_api_container`` вручную. Далее таких проблем не наблюдается;
     - При тестировании API в Swagger в поле ``Authorization`` необходимо вводить токен в таком формате: ``Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1In0.8w7kphtxqbW7O7RH2yMqOr-Y1QB40kWLBQcNSBVF9CQ``;
     - При создании баннеров для заполнения обязательны поля context. Все они должны быть заполнены;
     - При обновлении баннеров, если в ``feature_id`` равен 0, то поле останется без изменений, если ``feature_id`` равно -1, то значение поля обнуляется:
     ```json
      Входной баннер
     {
         "banner_id": 4,
        // какие-то поля
       "feature_id": 0,
       // какие-то поля
     }
     Баннер из БД
     {
        "banner_id": 4,
       // какие-то поля
       "feature_id": 4,
       // какие-то поля
     }
     Баннер после обновлнения
     {
        "banner_id": 4,
       // какие-то поля
         "feature_id": 4,
       // какие-то поля
     }
     ```
     
   ```json
      Входной баннер
     {
         "banner_id": 4,
        // какие-то поля
       "feature_id": -1,
       // какие-то поля
     }
     Баннер из БД
     {
        "banner_id": 4,
       // какие-то поля
       "feature_id": 4,
       // какие-то поля
     }
     Баннер после обновлнения
     {
        "banner_id": 4,
       // какие-то поля
         "feature_id": 0,
       // какие-то поля
     }
     ```
   - При обновлении баннеров, если в поле ``tags_ids``, указаны теги, которые уже были связаны с баннером, то они отвязываются от баннера; если указаны непривязанные, то они соответственно добавляются к баннеру;
     если приходит ноль или размер массива равен нулю, то список тегов баннера остается без изменений:
     ```
     Входной баннер
     {
         "banner_id": 4,
        // какие-то поля
       "tags_ids":[1,2,3],
       // какие-то поля
     }
     Баннер из БД
     {
        "banner_id": 4,
       // какие-то поля
       "tags_ids": [1,2,3],
       // какие-то поля
     }
     Баннер после обновлнения
     {
        "banner_id": 4,
       // какие-то поля
         "tags_ids": [],
       // какие-то поля
     }
     ```
      ```
      Входной баннер
     {
         "banner_id": 4,
        // какие-то поля
       "tags_ids":[4,5,6],
       // какие-то поля
     }
     Баннер из БД
     {
        "banner_id": 4,
       // какие-то поля
       "tags_ids": [1,2,3],
       // какие-то поля
     }
     Баннер после обновлнения
     {
        "banner_id": 4,
       // какие-то поля
         "tags_ids": [1,2,3,4,5,6],
       // какие-то поля
     }
     ```
      ```
      Входной баннер
     {
         "banner_id": 4,
        // какие-то поля
       "tags_ids":[4,5,6],
       // какие-то поля
     }
     Баннер из БД
     {
        "banner_id": 4,
       // какие-то поля
       "tags_ids": [1,2,3,4,5],
       // какие-то поля
     }
     Баннер после обновлнения
     {
        "banner_id": 4,
       // какие-то поля
         "tags_ids": [1,2,3,6],
       // какие-то поля
     }```

   - Поле ``url`` должно содержать валидную ссылку.
  8. Были добавлены метрики с использованием prometheus. Их можно получить по ``localhost:9090``. Были реализованы 2 кастомные метрики: ``http_request_duration_seconds`` и ``response_status``. Они были добавлены
     для оценки 4 golden signals приложения при нагрузочном тестировании, которое, к сожалению, не успел реализовать.

  ## Итог
  В целом остался доволен своей работай. К сожалению не смог уделить больше времени и сделать больше и менее "кустарно" все задачи. Проблем, которые сложно решить в ходе выполнения, не было. Все можно было решить своими силами.
     
